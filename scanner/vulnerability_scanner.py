# ===================================================================
# scanner/vulnerability_scanner.py - Scanner vulnerabilità avanzato
import re
import requests
import json
from datetime import datetime, timedelta


class VulnerabilityScanner:
    """Scanner vulnerabilità con integrazione NVD"""

    def __init__(self, cache_manager):
        self.cache = cache_manager
        self.nvd_base_url = "https://services.nvd.nist.gov/rest/json"

    def analyze_nmap_vulnerability_output(self, xml_content, ip_address):
        """Analizza output XML di nmap vulnerability scan"""
        vulnerabilities = []

        try:
            import xml.etree.ElementTree as ET
            root = ET.fromstring(xml_content)

            for host in root.findall('.//host'):
                address = host.find('.//address[@addrtype="ipv4"]')
                if address is None or address.get('addr') != ip_address:
                    continue

                # Analizza script results
                for script in host.findall('.//script'):
                    script_id = script.get('id', '')
                    output = script.get('output', '')

                    # Estrae vulnerabilità da diversi script
                    vulns = self._extract_vulnerabilities_from_script(script_id, output)
                    vulnerabilities.extend(vulns)

                # Analizza anche hostscript
                for hostscript in root.findall('.//hostscript/script'):
                    script_id = hostscript.get('id', '')
                    output = hostscript.get('output', '')

                    vulns = self._extract_vulnerabilities_from_script(script_id, output)
                    vulnerabilities.extend(vulns)

        except Exception as e:
            print(f"Errore analisi XML vulnerabilità: {e}")

        return vulnerabilities

    def _extract_vulnerabilities_from_script(self, script_id, output):
        """Estrae vulnerabilità da output script specifico"""
        vulnerabilities = []

        # Pattern per diversi tipi di vulnerabilità
        patterns = {
            'cve': r'CVE-\d{4}-\d{4,7}',
            'ms_bulletin': r'MS\d{2}-\d{3}',
            'osvdb': r'OSVDB-\d+',
            'bid': r'BID-\d+',
            'edb': r'EDB-\d+'
        }

        for vuln_type, pattern in patterns.items():
            matches = re.findall(pattern, output, re.IGNORECASE)

            for match in matches:
                vuln = {
                    'id': match,
                    'type': vuln_type,
                    'script': script_id,
                    'raw_output': output,
                    'severity': self._estimate_severity_from_output(output),
                    'confidence': self._estimate_confidence_from_script(script_id)
                }

                # Arricchisci con dati NVD se CVE
                if vuln_type == 'cve':
                    cve_data = self.cache.get_cve_info(match)
                    if cve_data:
                        vuln.update(cve_data)

                vulnerabilities.append(vuln)

        # Analizza vulnerabilità specifiche per script
        if 'smb-vuln' in script_id:
            vulns = self._parse_smb_vulnerabilities(output)
            vulnerabilities.extend(vulns)

        elif 'ssl-' in script_id:
            vulns = self._parse_ssl_vulnerabilities(output)
            vulnerabilities.extend(vulns)

        elif 'http-vuln' in script_id:
            vulns = self._parse_http_vulnerabilities(output)
            vulnerabilities.extend(vulns)

        return vulnerabilities

    def _parse_smb_vulnerabilities(self, output):
        """Parse vulnerabilità SMB specifiche"""
        vulnerabilities = []

        # Vulnerabilità SMB note
        smb_vulns = {
            'ms08-067': {'name': 'MS08-067', 'severity': 'CRITICAL', 'score': 10.0},
            'ms17-010': {'name': 'MS17-010 (EternalBlue)', 'severity': 'CRITICAL', 'score': 9.3},
            'ms06-025': {'name': 'MS06-025', 'severity': 'HIGH', 'score': 9.3},
            'ms05-039': {'name': 'MS05-039', 'severity': 'HIGH', 'score': 9.3}
        }

        for vuln_key, vuln_data in smb_vulns.items():
            if vuln_key.upper() in output.upper() or 'VULNERABLE' in output.upper():
                vulnerabilities.append({
                    'id': vuln_data['name'],
                    'type': 'smb',
                    'severity': vuln_data['severity'],
                    'score': vuln_data['score'],
                    'description': f"SMB vulnerability: {vuln_data['name']}"
                })

        return vulnerabilities

    def _parse_ssl_vulnerabilities(self, output):
        """Parse vulnerabilità SSL specifiche"""
        vulnerabilities = []

        ssl_vulns = [
            ('POODLE', 'SSL 3.0 POODLE vulnerability', 'MEDIUM', 4.3),
            ('BEAST', 'SSL/TLS BEAST vulnerability', 'MEDIUM', 4.3),
            ('HEARTBLEED', 'OpenSSL Heartbleed vulnerability', 'HIGH', 7.5),
            ('FREAK', 'SSL/TLS FREAK vulnerability', 'MEDIUM', 4.3),
            ('LOGJAM', 'SSL/TLS Logjam vulnerability', 'MEDIUM', 5.3)
        ]

        for vuln_name, description, severity, score in ssl_vulns:
            if vuln_name.upper() in output.upper():
                vulnerabilities.append({
                    'id': vuln_name,
                    'type': 'ssl',
                    'severity': severity,
                    'score': score,
                    'description': description
                })

        return vulnerabilities

    def _parse_http_vulnerabilities(self, output):
        """Parse vulnerabilità HTTP specifiche"""
        vulnerabilities = []

        # Cerca indicatori comuni di vulnerabilità web
        if 'XSS' in output.upper():
            vulnerabilities.append({
                'id': 'XSS-DETECTED',
                'type': 'web',
                'severity': 'MEDIUM',
                'score': 6.1,
                'description': 'Cross-Site Scripting vulnerability detected'
            })

        if 'SQL INJECTION' in output.upper():
            vulnerabilities.append({
                'id': 'SQLI-DETECTED',
                'type': 'web',
                'severity': 'HIGH',
                'score': 9.8,
                'description': 'SQL Injection vulnerability detected'
            })

        return vulnerabilities

    def _estimate_severity_from_output(self, output):
        """Stima severity da output script"""
        output_upper = output.upper()

        if any(word in output_upper for word in ['CRITICAL', 'EXPLOIT', 'REMOTE CODE']):
            return 'CRITICAL'
        elif any(word in output_upper for word in ['HIGH', 'DANGEROUS', 'VULNERABLE']):
            return 'HIGH'
        elif any(word in output_upper for word in ['MEDIUM', 'WARNING']):
            return 'MEDIUM'
        elif any(word in output_upper for word in ['LOW', 'INFO']):
            return 'LOW'
        else:
            return 'UNKNOWN'

    def _estimate_confidence_from_script(self, script_id):
        """Stima confidence in base allo script"""
        high_confidence_scripts = [
            'smb-vuln-ms08-067',
            'smb-vuln-ms17-010',
            'ssl-heartbleed',
            'http-vuln-cve'
        ]

        for script in high_confidence_scripts:
            if script in script_id:
                return 'HIGH'

        return 'MEDIUM'

    def search_exploits(self, cve_id):
        """Cerca exploit disponibili per CVE"""
        exploits = []

        # Fonti di exploit da cercare
        sources = [
            f"https://www.exploit-db.com/search?cve={cve_id}",
            f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
        ]

        # Per ora ritorna le fonti, implementazione completa richiederebbe
        # scraping o API specifiche
        return {
            'cve_id': cve_id,
            'sources': sources,
            'exploit_found': False  # Placeholder
        }