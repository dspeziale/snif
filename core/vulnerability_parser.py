#!/usr/bin/env python3
"""
Vulnerability Parser - Gestisce il parsing delle vulnerabilità da script NSE
"""

import xml.etree.ElementTree as ET
import re
from typing import Dict, List, Optional
import logging

logger = logging.getLogger(__name__)


class VulnerabilityParser:
    """Parser specializzato per vulnerabilità da script NSE"""

    def __init__(self, database_manager):
        """Inizializza il parser con riferimento al database manager"""
        self.db = database_manager

    def parse_vulnerabilities(self, xml_file_path: str):
        """Parse vulnerabilità da file XML"""
        try:
            tree = ET.parse(xml_file_path)
            root = tree.getroot()

            vulnerabilities_found = 0

            for host in root.findall('host'):
                ip_addr = self._get_host_ip(host)
                if not ip_addr:
                    continue

                # Parse vulnerabilità da script a livello host
                host_vulns = self._parse_host_vulnerabilities(host, ip_addr)
                vulnerabilities_found += host_vulns

                # Parse vulnerabilità da script a livello porta
                port_vulns = self._parse_port_vulnerabilities(host, ip_addr)
                vulnerabilities_found += port_vulns

            self.db.commit()
            logger.info(f"Trovate {vulnerabilities_found} vulnerabilità in {xml_file_path}")

        except Exception as e:
            logger.error(f"Errore nel parsing vulnerabilità da {xml_file_path}: {e}")

    def _get_host_ip(self, host) -> Optional[str]:
        """Estrae l'IP dell'host"""
        for address in host.findall('address'):
            if address.get('addrtype') == 'ipv4':
                return address.get('addr')
        return None

    def _parse_host_vulnerabilities(self, host, ip_addr: str) -> int:
        """Parse vulnerabilità da script a livello host"""
        vulns_found = 0

        hostscript = host.find('hostscript')
        if hostscript is None:
            return 0

        for script in hostscript.findall('script'):
            script_name = script.get('id', '')
            output = script.get('output', '')

            if self._is_vulnerability_script(script_name) and output:
                vulns = self._extract_vulnerabilities_from_script(
                    ip_addr, None, None, script_name, output
                )
                vulns_found += len(vulns)

        return vulns_found

    def _parse_port_vulnerabilities(self, host, ip_addr: str) -> int:
        """Parse vulnerabilità da script a livello porta"""
        vulns_found = 0

        ports_elem = host.find('ports')
        if ports_elem is None:
            return 0

        for port in ports_elem.findall('port'):
            try:
                port_num = int(port.get('portid'))
                protocol = port.get('protocol', 'tcp')

                for script in port.findall('script'):
                    script_name = script.get('id', '')
                    output = script.get('output', '')

                    if self._is_vulnerability_script(script_name) and output:
                        vulns = self._extract_vulnerabilities_from_script(
                            ip_addr, port_num, protocol, script_name, output
                        )
                        vulns_found += len(vulns)

            except Exception as e:
                logger.warning(f"Errore parsing vulnerabilità porta {port.get('portid')}: {e}")

        return vulns_found

    def _is_vulnerability_script(self, script_name: str) -> bool:
        """Determina se lo script rileva vulnerabilità"""
        vuln_keywords = [
            'vuln', 'cve', 'exploit', 'security', 'weakness',
            'vulnerability', 'disclosure', 'advisory', 'ms-',
            'kb-', 'smb-vuln', 'ssl-vuln', 'http-vuln'
        ]

        script_lower = script_name.lower()
        return any(keyword in script_lower for keyword in vuln_keywords)

    def _extract_vulnerabilities_from_script(self, ip_addr: str, port_num: Optional[int],
                                             protocol: Optional[str], script_name: str,
                                             output: str) -> List[Dict]:
        """Estrae vulnerabilità dall'output di uno script"""
        vulnerabilities = []

        try:
            # Diversi parser basati sul tipo di script
            if 'smb-vuln' in script_name:
                vulnerabilities.extend(self._parse_smb_vulnerabilities(
                    ip_addr, port_num, protocol, script_name, output
                ))
            elif 'ssl-vuln' in script_name or 'ssl-' in script_name:
                vulnerabilities.extend(self._parse_ssl_vulnerabilities(
                    ip_addr, port_num, protocol, script_name, output
                ))
            elif 'http-vuln' in script_name:
                vulnerabilities.extend(self._parse_http_vulnerabilities(
                    ip_addr, port_num, protocol, script_name, output
                ))
            else:
                vulnerabilities.extend(self._parse_generic_vulnerabilities(
                    ip_addr, port_num, protocol, script_name, output
                ))

            # Inserisci tutte le vulnerabilità trovate
            for vuln in vulnerabilities:
                self.db.insert_vulnerability(vuln)

        except Exception as e:
            logger.warning(f"Errore estrazione vulnerabilità da {script_name}: {e}")

        return vulnerabilities

    def _parse_smb_vulnerabilities(self, ip_addr: str, port_num: Optional[int],
                                   protocol: Optional[str], script_name: str,
                                   output: str) -> List[Dict]:
        """Parse vulnerabilità SMB"""
        vulnerabilities = []

        # Pattern per vulnerabilità SMB comuni
        patterns = {
            'MS17-010': {
                'pattern': r'MS17-010.*?VULNERABLE',
                'severity': 'CRITICAL',
                'title': 'SMB Remote Code Execution Vulnerability (EternalBlue)',
                'cve_id': 'CVE-2017-0144'
            },
            'MS08-067': {
                'pattern': r'MS08-067.*?VULNERABLE',
                'severity': 'CRITICAL',
                'title': 'SMB Server vulnerability (MS08-067)',
                'cve_id': 'CVE-2008-4250'
            },
            'MS10-061': {
                'pattern': r'MS10-061.*?VULNERABLE',
                'severity': 'HIGH',
                'title': 'Print Spooler Service vulnerability',
                'cve_id': 'CVE-2010-2729'
            }
        }

        for vuln_name, vuln_info in patterns.items():
            if re.search(vuln_info['pattern'], output, re.IGNORECASE):
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'SMB',
                    'severity': vuln_info['severity'],
                    'title': vuln_info['title'],
                    'description': f"Vulnerabilità {vuln_name} rilevata tramite {script_name}",
                    'vuln_references': f"Microsoft Security Bulletin {vuln_name}",
                    'cvss_score': self._get_cvss_score_by_severity(vuln_info['severity']),
                    'cve_id': vuln_info['cve_id']
                }
                vulnerabilities.append(vuln_data)

        return vulnerabilities

    def _parse_ssl_vulnerabilities(self, ip_addr: str, port_num: Optional[int],
                                   protocol: Optional[str], script_name: str,
                                   output: str) -> List[Dict]:
        """Parse vulnerabilità SSL/TLS"""
        vulnerabilities = []

        # Pattern per vulnerabilità SSL/TLS comuni
        ssl_patterns = {
            'POODLE': {
                'pattern': r'POODLE.*?VULNERABLE',
                'severity': 'MEDIUM',
                'title': 'POODLE SSL 3.0 vulnerability',
                'cve_id': 'CVE-2014-3566'
            },
            'BEAST': {
                'pattern': r'BEAST.*?VULNERABLE',
                'severity': 'MEDIUM',
                'title': 'BEAST SSL/TLS vulnerability',
                'cve_id': 'CVE-2011-3389'
            },
            'CRIME': {
                'pattern': r'CRIME.*?VULNERABLE',
                'severity': 'MEDIUM',
                'title': 'CRIME SSL/TLS vulnerability',
                'cve_id': 'CVE-2012-4929'
            },
            'HEARTBLEED': {
                'pattern': r'HEARTBLEED.*?VULNERABLE',
                'severity': 'CRITICAL',
                'title': 'Heartbleed OpenSSL vulnerability',
                'cve_id': 'CVE-2014-0160'
            },
            'LOGJAM': {
                'pattern': r'LOGJAM.*?VULNERABLE',
                'severity': 'MEDIUM',
                'title': 'Logjam DH vulnerability',
                'cve_id': 'CVE-2015-4000'
            }
        }

        for vuln_name, vuln_info in ssl_patterns.items():
            if re.search(vuln_info['pattern'], output, re.IGNORECASE):
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'SSL/TLS',
                    'severity': vuln_info['severity'],
                    'title': vuln_info['title'],
                    'description': f"Vulnerabilità SSL/TLS {vuln_name} rilevata tramite {script_name}",
                    'vuln_references': f"SSL/TLS vulnerability {vuln_name}",
                    'cvss_score': self._get_cvss_score_by_severity(vuln_info['severity']),
                    'cve_id': vuln_info['cve_id']
                }
                vulnerabilities.append(vuln_data)

        # Cerca anche cipher deboli
        if 'weak' in output.lower() or 'insecure' in output.lower():
            weak_cipher_match = re.search(r'(weak|insecure).*?cipher', output, re.IGNORECASE)
            if weak_cipher_match:
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'SSL/TLS',
                    'severity': 'LOW',
                    'title': 'Weak SSL/TLS Cipher Suites',
                    'description': f"Cipher SSL/TLS deboli rilevati tramite {script_name}",
                    'vuln_references': 'SSL/TLS Best Practices',
                    'cvss_score': 3.1,
                    'cve_id': None
                }
                vulnerabilities.append(vuln_data)

        return vulnerabilities

    def _parse_http_vulnerabilities(self, ip_addr: str, port_num: Optional[int],
                                    protocol: Optional[str], script_name: str,
                                    output: str) -> List[Dict]:
        """Parse vulnerabilità HTTP/Web"""
        vulnerabilities = []

        # Pattern per vulnerabilità web comuni
        web_patterns = {
            'XSS': {
                'pattern': r'XSS|cross.site.scripting',
                'severity': 'MEDIUM',
                'title': 'Cross-Site Scripting (XSS) vulnerability'
            },
            'SQLi': {
                'pattern': r'SQL.injection|SQLi',
                'severity': 'HIGH',
                'title': 'SQL Injection vulnerability'
            },
            'CSRF': {
                'pattern': r'CSRF|cross.site.request.forgery',
                'severity': 'MEDIUM',
                'title': 'Cross-Site Request Forgery vulnerability'
            },
            'Directory Traversal': {
                'pattern': r'directory.traversal|path.traversal',
                'severity': 'HIGH',
                'title': 'Directory Traversal vulnerability'
            },
            'Command Injection': {
                'pattern': r'command.injection|code.injection',
                'severity': 'CRITICAL',
                'title': 'Command Injection vulnerability'
            }
        }

        for vuln_name, vuln_info in web_patterns.items():
            if re.search(vuln_info['pattern'], output, re.IGNORECASE):
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'Web',
                    'severity': vuln_info['severity'],
                    'title': vuln_info['title'],
                    'description': f"Vulnerabilità web {vuln_name} rilevata tramite {script_name}",
                    'vuln_references': f"OWASP Top 10 - {vuln_name}",
                    'cvss_score': self._get_cvss_score_by_severity(vuln_info['severity']),
                    'cve_id': None
                }
                vulnerabilities.append(vuln_data)

        return vulnerabilities

    def _parse_generic_vulnerabilities(self, ip_addr: str, port_num: Optional[int],
                                       protocol: Optional[str], script_name: str,
                                       output: str) -> List[Dict]:
        """Parse generico per vulnerabilità"""
        vulnerabilities = []

        # Cerca CVE specifici nell'output
        cve_pattern = r'CVE-(\d{4}-\d{4,7})'
        cve_matches = re.findall(cve_pattern, output, re.IGNORECASE)

        for cve_match in cve_matches:
            cve_id = f"CVE-{cve_match}"

            # Determina severità dal contesto
            severity = self._determine_severity_from_context(output, cve_id)

            vuln_data = {
                'ip_address': ip_addr,
                'port_number': port_num,
                'protocol': protocol,
                'vuln_type': 'General',
                'severity': severity,
                'title': f"Vulnerability {cve_id}",
                'description': f"CVE {cve_id} rilevato tramite {script_name}",
                'vuln_references': f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
                'cvss_score': self._get_cvss_score_by_severity(severity),
                'cve_id': cve_id
            }
            vulnerabilities.append(vuln_data)

        # Cerca keywords generiche di vulnerabilità
        vuln_keywords = {
            'vulnerable': 'MEDIUM',
            'exploitable': 'HIGH',
            'critical': 'CRITICAL',
            'severe': 'HIGH',
            'weak': 'LOW',
            'insecure': 'MEDIUM'
        }

        for keyword, severity in vuln_keywords.items():
            if keyword in output.lower():
                # Evita duplicati se già trovato CVE
                if not cve_matches:
                    vuln_data = {
                        'ip_address': ip_addr,
                        'port_number': port_num,
                        'protocol': protocol,
                        'vuln_type': 'General',
                        'severity': severity,
                        'title': f"Security Issue detected by {script_name}",
                        'description': f"Possibile vulnerabilità rilevata tramite {script_name}: {keyword}",
                        'vuln_references': f"Nmap script: {script_name}",
                        'cvss_score': self._get_cvss_score_by_severity(severity),
                        'cve_id': None
                    }
                    vulnerabilities.append(vuln_data)
                    break  # Solo una vulnerabilità generica per script

        return vulnerabilities

    def _determine_severity_from_context(self, output: str, cve_id: str) -> str:
        """Determina la severità dal contesto dell'output"""
        output_lower = output.lower()

        if any(word in output_lower for word in ['critical', 'severe', 'remote code execution']):
            return 'CRITICAL'
        elif any(word in output_lower for word in ['high', 'dangerous', 'exploit']):
            return 'HIGH'
        elif any(word in output_lower for word in ['medium', 'moderate']):
            return 'MEDIUM'
        elif any(word in output_lower for word in ['low', 'minor', 'info']):
            return 'LOW'
        else:
            return 'MEDIUM'  # Default

    def _get_cvss_score_by_severity(self, severity: str) -> float:
        """Restituisce un CVSS score approssimativo basato sulla severità"""
        severity_scores = {
            'CRITICAL': 9.0,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 3.0,
            'INFO': 0.0
        }
        return severity_scores.get(severity.upper(), 5.0)

    def get_vulnerability_summary(self) -> Dict:
        """Genera un riassunto delle vulnerabilità nel database"""
        try:
            summary = {}

            # Conteggio totale vulnerabilità
            self.db.cursor.execute('SELECT COUNT(*) FROM vulnerabilities')
            summary['total_vulnerabilities'] = self.db.cursor.fetchone()[0]

            # Conteggio per severità
            self.db.cursor.execute('''
                SELECT severity, COUNT(*) 
                FROM vulnerabilities 
                GROUP BY severity 
                ORDER BY 
                    CASE severity 
                        WHEN 'CRITICAL' THEN 1 
                        WHEN 'HIGH' THEN 2 
                        WHEN 'MEDIUM' THEN 3 
                        WHEN 'LOW' THEN 4 
                        ELSE 5 
                    END
            ''')
            summary['by_severity'] = dict(self.db.cursor.fetchall())

            # Conteggio per tipo
            self.db.cursor.execute('''
                SELECT vuln_type, COUNT(*) 
                FROM vulnerabilities 
                GROUP BY vuln_type 
                ORDER BY COUNT(*) DESC
            ''')
            summary['by_type'] = dict(self.db.cursor.fetchall())

            # Host più vulnerabili
            self.db.cursor.execute('''
                SELECT ip_address, COUNT(*) as vuln_count
                FROM vulnerabilities 
                GROUP BY ip_address 
                ORDER BY vuln_count DESC 
                LIMIT 10
            ''')
            summary['most_vulnerable_hosts'] = self.db.cursor.fetchall()

            # CVE più comuni
            self.db.cursor.execute('''
                SELECT cve_id, COUNT(*) as count
                FROM vulnerabilities 
                WHERE cve_id IS NOT NULL 
                GROUP BY cve_id 
                ORDER BY count DESC 
                LIMIT 10
            ''')
            summary['common_cves'] = self.db.cursor.fetchall()

            return summary

        except Exception as e:
            logger.error(f"Errore generazione summary vulnerabilità: {e}")
            return {}

    def export_vulnerabilities_report(self, output_file: str = "../reports/vulnerabilities_report.txt"):
        """Esporta un report dettagliato delle vulnerabilità"""
        try:
            import os
            os.makedirs("../reports", exist_ok=True)

            with open(output_file, 'w', encoding='utf-8') as f:
                f.write("REPORT VULNERABILITÀ NETWORK SCAN\n")
                f.write("=" * 50 + "\n\n")

                # Summary
                summary = self.get_vulnerability_summary()
                f.write(f"Vulnerabilità totali trovate: {summary.get('total_vulnerabilities', 0)}\n\n")

                if summary.get('by_severity'):
                    f.write("Distribuzione per severità:\n")
                    for severity, count in summary['by_severity'].items():
                        f.write(f"  {severity}: {count}\n")
                    f.write("\n")

                # Dettaglio vulnerabilità critiche e high
                self.db.cursor.execute('''
                    SELECT ip_address, port_number, protocol, severity, title, cve_id, description
                    FROM vulnerabilities 
                    WHERE severity IN ('CRITICAL', 'HIGH')
                    ORDER BY 
                        CASE severity WHEN 'CRITICAL' THEN 1 ELSE 2 END,
                        ip_address
                ''')

                critical_high_vulns = self.db.cursor.fetchall()

                if critical_high_vulns:
                    f.write("VULNERABILITÀ CRITICHE E HIGH:\n")
                    f.write("-" * 40 + "\n")

                    for vuln in critical_high_vulns:
                        ip, port, proto, sev, title, cve, desc = vuln
                        f.write(f"\nHost: {ip}")
                        if port:
                            f.write(f" - Porta: {port}/{proto}")
                        f.write(f"\nSeverità: {sev}")
                        f.write(f"\nTitolo: {title}")
                        if cve:
                            f.write(f"\nCVE: {cve}")
                        f.write(f"\nDescrizione: {desc}")
                        f.write(f"\n{'-' * 30}\n")

                f.write("\nReport generato automaticamente dal parser Nmap XML\n")

            logger.info(f"Report vulnerabilità esportato in: {output_file}")

        except Exception as e:
            logger.error(f"Errore esportazione report vulnerabilità: {e}")