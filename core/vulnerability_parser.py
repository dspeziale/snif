#!/usr/bin/env python3
"""
Vulnerability Parser - VERSIONE CORRETTA
Gestisce il parsing delle vulnerabilità da script NSE con recognition migliorato
"""

import xml.etree.ElementTree as ET
import re
from typing import Dict, List, Optional
import logging

logger = logging.getLogger(__name__)


class VulnerabilityParser:
    """Parser specializzato per vulnerabilità da script NSE - VERSIONE CORRETTA"""

    def __init__(self, database_manager):
        """Inizializza il parser con riferimento al database manager"""
        self.db = database_manager

    def parse_vulnerabilities(self, xml_file_path: str):
        """Parse vulnerabilità da file XML"""
        try:
            tree = ET.parse(xml_file_path)
            root = tree.getroot()

            vulnerabilities_found = 0

            for host in root.findall('host'):
                ip_addr = self._get_host_ip(host)
                if not ip_addr:
                    continue

                # Parse vulnerabilità da script a livello host
                host_vulns = self._parse_host_vulnerabilities(host, ip_addr)
                vulnerabilities_found += host_vulns

                # Parse vulnerabilità da script a livello porta
                port_vulns = self._parse_port_vulnerabilities(host, ip_addr)
                vulnerabilities_found += port_vulns

            self.db.commit()
            logger.info(f"Trovate {vulnerabilities_found} vulnerabilità in {xml_file_path}")

        except Exception as e:
            logger.error(f"Errore nel parsing vulnerabilità da {xml_file_path}: {e}")

    def _get_host_ip(self, host) -> Optional[str]:
        """Estrae l'IP dell'host"""
        for address in host.findall('address'):
            if address.get('addrtype') == 'ipv4':
                return address.get('addr')
        return None

    def _parse_host_vulnerabilities(self, host, ip_addr: str) -> int:
        """Parse vulnerabilità da script a livello host"""
        vulns_found = 0

        hostscript = host.find('hostscript')
        if hostscript is None:
            return 0

        for script in hostscript.findall('script'):
            script_name = script.get('id', '')
            output = script.get('output', '')

            if self._is_vulnerability_script(script_name) and output:
                vulns = self._extract_vulnerabilities_from_script(
                    ip_addr, None, None, script_name, output
                )
                vulns_found += len(vulns)

        return vulns_found

    def _parse_port_vulnerabilities(self, host, ip_addr: str) -> int:
        """Parse vulnerabilità da script a livello porta"""
        vulns_found = 0

        ports_elem = host.find('ports')
        if ports_elem is None:
            return 0

        for port in ports_elem.findall('port'):
            try:
                port_num = int(port.get('portid'))
                protocol = port.get('protocol', 'tcp')

                for script in port.findall('script'):
                    script_name = script.get('id', '')
                    output = script.get('output', '')

                    if self._is_vulnerability_script(script_name) and output:
                        vulns = self._extract_vulnerabilities_from_script(
                            ip_addr, port_num, protocol, script_name, output
                        )
                        vulns_found += len(vulns)

            except Exception as e:
                logger.warning(f"Errore parsing vulnerabilità porta {port.get('portid')}: {e}")

        return vulns_found

    def _is_vulnerability_script(self, script_name: str) -> bool:
        """Determina se lo script rileva vulnerabilità - VERSIONE CORRETTA"""

        # Lista estesa di keywords per riconoscere script di vulnerabilità
        vuln_keywords = [
            # Keywords generiche
            'vuln', 'vulnerability', 'cve', 'exploit', 'security', 'weakness',
            'disclosure', 'advisory', 'exposure',

            # Keywords specifiche Web
            'xss', 'csrf', 'injection', 'sqli', 'sql-injection',
            'file-upload', 'upload', 'directory-traversal', 'path-traversal',
            'command-injection', 'code-injection', 'rfi', 'lfi',
            'sourcecode', 'backup', 'config', 'enum',

            # Keywords Microsoft
            'ms-', 'kb-', 'ms08-067', 'ms17-010', 'ms10-061',

            # Keywords protocollo-specifiche
            'smb-vuln', 'ssl-vuln', 'ssh-vuln', 'ftp-vuln',

            # Keywords HTTP specifiche
            'http-vuln', 'http-enum', 'http-methods', 'http-trace',
            'http-open-proxy', 'http-shellshock', 'http-slowloris',

            # Altri patterns comuni
            'brute', 'crack', 'bypass', 'escalation', 'overflow',
            'dos', 'ddos', 'flood', 'amplification'
        ]

        script_lower = script_name.lower()

        # Controlla keywords dirette
        for keyword in vuln_keywords:
            if keyword in script_lower:
                return True

        # Pattern aggiuntivi per script HTTP di sicurezza
        http_security_patterns = [
            r'http-.*xss',
            r'http-.*csrf',
            r'http-.*inject',
            r'http-.*exploit',
            r'http-.*enum',
            r'http-.*brute',
            r'http-.*upload',
            r'http-.*traversal',
            r'http-.*bypass',
            r'http-.*disclosure'
        ]

        for pattern in http_security_patterns:
            if re.search(pattern, script_lower):
                return True

        return False

    def _extract_vulnerabilities_from_script(self, ip_addr: str, port_num: Optional[int],
                                             protocol: Optional[str], script_name: str,
                                             output: str) -> List[Dict]:
        """Estrae vulnerabilità dall'output di uno script"""
        vulnerabilities = []

        try:
            # Parser specifici per diversi tipi di script
            if 'smb-vuln' in script_name or 'ms-' in script_name:
                vulnerabilities.extend(self._parse_smb_vulnerabilities(
                    ip_addr, port_num, protocol, script_name, output
                ))
            elif 'ssl-vuln' in script_name or 'ssl-' in script_name:
                vulnerabilities.extend(self._parse_ssl_vulnerabilities(
                    ip_addr, port_num, protocol, script_name, output
                ))
            elif script_name.startswith('http-'):
                vulnerabilities.extend(self._parse_http_vulnerabilities(
                    ip_addr, port_num, protocol, script_name, output
                ))
            else:
                vulnerabilities.extend(self._parse_generic_vulnerabilities(
                    ip_addr, port_num, protocol, script_name, output
                ))

            # Inserisci tutte le vulnerabilità trovate
            for vuln in vulnerabilities:
                self.db.insert_vulnerability(vuln)

        except Exception as e:
            logger.warning(f"Errore estrazione vulnerabilità da {script_name}: {e}")

        return vulnerabilities

    def _parse_http_vulnerabilities(self, ip_addr: str, port_num: Optional[int],
                                    protocol: Optional[str], script_name: str,
                                    output: str) -> List[Dict]:
        """Parse vulnerabilità HTTP/Web - VERSIONE MIGLIORATA"""
        vulnerabilities = []

        # Analizza output per trovare vulnerabilità specifiche
        output_lower = output.lower()

        # 1. Cross-Site Scripting (XSS)
        if 'xss' in script_name:
            if 'found' in output_lower and ('xss' in output_lower or 'dom based' in output_lower):
                severity = 'MEDIUM' if 'dom' in script_name else 'HIGH'

                # Estrai dettagli specifici
                sources = re.findall(r'Source:\s*(.+)', output, re.IGNORECASE)
                pages = re.findall(r'Pages:\s*(.+)', output, re.IGNORECASE)

                description = f"XSS vulnerability detected via {script_name}"
                if sources:
                    description += f". Source: {sources[0][:100]}..."
                if pages:
                    description += f". Found on: {pages[0][:100]}..."

                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'Web Application',
                    'severity': severity,
                    'title': f"Cross-Site Scripting ({script_name})",
                    'description': description,
                    'vuln_references': 'OWASP Top 10 - A03:2021 Injection',
                    'cvss_score': 6.1 if severity == 'MEDIUM' else 7.5,
                    'cve_id': None
                }
                vulnerabilities.append(vuln_data)

        # 2. Cross-Site Request Forgery (CSRF)
        elif 'csrf' in script_name:
            if 'found' in output_lower and 'csrf' in output_lower:
                # Estrai dettagli del form
                forms = re.findall(r'Form id:\s*(.+)', output)
                actions = re.findall(r'Form action:\s*(.+)', output)

                description = f"CSRF vulnerability detected via {script_name}"
                if forms:
                    description += f". Vulnerable form: {forms[0]}"
                if actions:
                    description += f". Action: {actions[0]}"

                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'Web Application',
                    'severity': 'MEDIUM',
                    'title': 'Cross-Site Request Forgery (CSRF)',
                    'description': description,
                    'vuln_references': 'OWASP Top 10 - A01:2021 Broken Access Control',
                    'cvss_score': 5.4,
                    'cve_id': None
                }
                vulnerabilities.append(vuln_data)

        # 3. File Upload Vulnerabilities
        elif 'upload' in script_name:
            if 'file-type field' not in output_lower:  # Se NON dice "couldn't find"
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'Web Application',
                    'severity': 'HIGH',
                    'title': 'Unrestricted File Upload',
                    'description': f"File upload functionality detected via {script_name}",
                    'vuln_references': 'OWASP Top 10 - A04:2021 Insecure Design',
                    'cvss_score': 7.5,
                    'cve_id': None
                }
                vulnerabilities.append(vuln_data)

        # 4. Information Disclosure
        elif 'sourcecode' in script_name or 'disclosure' in script_name:
            if 'might not be vulnerable' not in output_lower:
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'Information Disclosure',
                    'severity': 'MEDIUM',
                    'title': 'Source Code Disclosure',
                    'description': f"Potential source code disclosure via {script_name}: {output[:200]}...",
                    'vuln_references': 'CWE-200: Information Exposure',
                    'cvss_score': 5.3,
                    'cve_id': None
                }
                vulnerabilities.append(vuln_data)

        # 5. Injection Vulnerabilities
        elif 'injection' in script_name or 'sqli' in script_name:
            if 'vulnerable' in output_lower or 'injection' in output_lower:
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'Injection',
                    'severity': 'HIGH',
                    'title': 'SQL/Code Injection',
                    'description': f"Injection vulnerability detected via {script_name}: {output[:200]}...",
                    'vuln_references': 'OWASP Top 10 - A03:2021 Injection',
                    'cvss_score': 8.1,
                    'cve_id': None
                }
                vulnerabilities.append(vuln_data)

        # 6. Generic HTTP Security Issues
        else:
            # Cerca pattern generici di problemi di sicurezza
            security_indicators = [
                ('vulnerable', 'MEDIUM'),
                ('exploitable', 'HIGH'),
                ('weakness', 'LOW'),
                ('exposed', 'MEDIUM'),
                ('misconfigured', 'MEDIUM')
            ]

            for indicator, severity in security_indicators:
                if indicator in output_lower:
                    vuln_data = {
                        'ip_address': ip_addr,
                        'port_number': port_num,
                        'protocol': protocol,
                        'vuln_type': 'Web Application',
                        'severity': severity,
                        'title': f"HTTP Security Issue ({script_name})",
                        'description': f"Security issue detected via {script_name}: {output[:300]}...",
                        'vuln_references': f"Nmap script: {script_name}",
                        'cvss_score': self._get_cvss_score_by_severity(severity),
                        'cve_id': None
                    }
                    vulnerabilities.append(vuln_data)
                    break

        return vulnerabilities

    def _parse_smb_vulnerabilities(self, ip_addr: str, port_num: Optional[int],
                                   protocol: Optional[str], script_name: str,
                                   output: str) -> List[Dict]:
        """Parse vulnerabilità SMB"""
        vulnerabilities = []

        # Pattern per vulnerabilità SMB comuni
        patterns = {
            'MS17-010': {
                'pattern': r'MS17-010.*?VULNERABLE',
                'severity': 'CRITICAL',
                'title': 'SMB Remote Code Execution Vulnerability (EternalBlue)',
                'cve_id': 'CVE-2017-0144'
            },
            'MS08-067': {
                'pattern': r'MS08-067.*?VULNERABLE',
                'severity': 'CRITICAL',
                'title': 'SMB Server vulnerability (MS08-067)',
                'cve_id': 'CVE-2008-4250'
            },
            'MS10-061': {
                'pattern': r'MS10-061.*?VULNERABLE',
                'severity': 'HIGH',
                'title': 'Print Spooler Service vulnerability',
                'cve_id': 'CVE-2010-2729'
            }
        }

        for vuln_name, vuln_info in patterns.items():
            if re.search(vuln_info['pattern'], output, re.IGNORECASE):
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'SMB',
                    'severity': vuln_info['severity'],
                    'title': vuln_info['title'],
                    'description': f"Vulnerabilità {vuln_name} rilevata tramite {script_name}",
                    'vuln_references': f"Microsoft Security Bulletin {vuln_name}",
                    'cvss_score': self._get_cvss_score_by_severity(vuln_info['severity']),
                    'cve_id': vuln_info['cve_id']
                }
                vulnerabilities.append(vuln_data)

        return vulnerabilities

    def _parse_ssl_vulnerabilities(self, ip_addr: str, port_num: Optional[int],
                                   protocol: Optional[str], script_name: str,
                                   output: str) -> List[Dict]:
        """Parse vulnerabilità SSL/TLS"""
        vulnerabilities = []

        # Pattern per vulnerabilità SSL/TLS comuni
        ssl_patterns = {
            'POODLE': {
                'pattern': r'POODLE.*?VULNERABLE',
                'severity': 'MEDIUM',
                'title': 'POODLE SSL 3.0 vulnerability',
                'cve_id': 'CVE-2014-3566'
            },
            'BEAST': {
                'pattern': r'BEAST.*?VULNERABLE',
                'severity': 'MEDIUM',
                'title': 'BEAST SSL/TLS vulnerability',
                'cve_id': 'CVE-2011-3389'
            },
            'CRIME': {
                'pattern': r'CRIME.*?VULNERABLE',
                'severity': 'MEDIUM',
                'title': 'CRIME SSL/TLS vulnerability',
                'cve_id': 'CVE-2012-4929'
            },
            'HEARTBLEED': {
                'pattern': r'HEARTBLEED.*?VULNERABLE',
                'severity': 'CRITICAL',
                'title': 'Heartbleed OpenSSL vulnerability',
                'cve_id': 'CVE-2014-0160'
            },
            'LOGJAM': {
                'pattern': r'LOGJAM.*?VULNERABLE',
                'severity': 'MEDIUM',
                'title': 'Logjam DH vulnerability',
                'cve_id': 'CVE-2015-4000'
            }
        }

        for vuln_name, vuln_info in ssl_patterns.items():
            if re.search(vuln_info['pattern'], output, re.IGNORECASE):
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'SSL/TLS',
                    'severity': vuln_info['severity'],
                    'title': vuln_info['title'],
                    'description': f"Vulnerabilità SSL/TLS {vuln_name} rilevata tramite {script_name}",
                    'vuln_references': f"SSL/TLS vulnerability {vuln_name}",
                    'cvss_score': self._get_cvss_score_by_severity(vuln_info['severity']),
                    'cve_id': vuln_info['cve_id']
                }
                vulnerabilities.append(vuln_data)

        # Cerca anche cipher deboli
        if 'weak' in output.lower() or 'insecure' in output.lower():
            weak_cipher_match = re.search(r'(weak|insecure).*?cipher', output, re.IGNORECASE)
            if weak_cipher_match:
                vuln_data = {
                    'ip_address': ip_addr,
                    'port_number': port_num,
                    'protocol': protocol,
                    'vuln_type': 'SSL/TLS',
                    'severity': 'LOW',
                    'title': 'Weak SSL/TLS Cipher Suites',
                    'description': f"Cipher SSL/TLS deboli rilevati tramite {script_name}",
                    'vuln_references': 'SSL/TLS Best Practices',
                    'cvss_score': 3.1,
                    'cve_id': None
                }
                vulnerabilities.append(vuln_data)

        return vulnerabilities

    def _parse_generic_vulnerabilities(self, ip_addr: str, port_num: Optional[int],
                                       protocol: Optional[str], script_name: str,
                                       output: str) -> List[Dict]:
        """Parse generico per vulnerabilità"""
        vulnerabilities = []

        # Cerca CVE specifici nell'output
        cve_pattern = r'CVE-(\d{4}-\d{4,7})'
        cve_matches = re.findall(cve_pattern, output, re.IGNORECASE)

        for cve_match in cve_matches:
            cve_id = f"CVE-{cve_match}"

            # Determina severità dal contesto
            severity = self._determine_severity_from_context(output, cve_id)

            vuln_data = {
                'ip_address': ip_addr,
                'port_number': port_num,
                'protocol': protocol,
                'vuln_type': 'General',
                'severity': severity,
                'title': f"Vulnerability {cve_id}",
                'description': f"CVE {cve_id} rilevato tramite {script_name}",
                'vuln_references': f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
                'cvss_score': self._get_cvss_score_by_severity(severity),
                'cve_id': cve_id
            }
            vulnerabilities.append(vuln_data)

        # Cerca keywords generiche di vulnerabilità se non ci sono CVE
        if not cve_matches:
            vuln_keywords = {
                'vulnerable': 'MEDIUM',
                'exploitable': 'HIGH',
                'critical': 'CRITICAL',
                'severe': 'HIGH',
                'weak': 'LOW',
                'insecure': 'MEDIUM',
                'exposed': 'MEDIUM',
                'disclosure': 'MEDIUM'
            }

            for keyword, severity in vuln_keywords.items():
                if keyword in output.lower():
                    vuln_data = {
                        'ip_address': ip_addr,
                        'port_number': port_num,
                        'protocol': protocol,
                        'vuln_type': 'General',
                        'severity': severity,
                        'title': f"Security Issue detected by {script_name}",
                        'description': f"Possibile vulnerabilità rilevata tramite {script_name}: {output[:300]}...",
                        'vuln_references': f"Nmap script: {script_name}",
                        'cvss_score': self._get_cvss_score_by_severity(severity),
                        'cve_id': None
                    }
                    vulnerabilities.append(vuln_data)
                    break  # Solo una vulnerabilità generica per script

        return vulnerabilities

    def _determine_severity_from_context(self, output: str, cve_id: str) -> str:
        """Determina la severità dal contesto dell'output"""
        output_lower = output.lower()

        if any(word in output_lower for word in ['critical', 'severe', 'remote code execution']):
            return 'CRITICAL'
        elif any(word in output_lower for word in ['high', 'dangerous', 'exploit']):
            return 'HIGH'
        elif any(word in output_lower for word in ['medium', 'moderate']):
            return 'MEDIUM'
        elif any(word in output_lower for word in ['low', 'minor', 'info']):
            return 'LOW'
        else:
            return 'MEDIUM'  # Default

    def _get_cvss_score_by_severity(self, severity: str) -> float:
        """Restituisce un CVSS score approssimativo basato sulla severità"""
        severity_scores = {
            'CRITICAL': 9.0,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 3.0,
            'INFO': 0.0
        }
        return severity_scores.get(severity.upper(), 5.0)

    def get_vulnerability_summary(self) -> Dict:
        """Genera un riassunto delle vulnerabilità nel database"""
        try:
            summary = {}

            # Conteggio totale vulnerabilità
            self.db.cursor.execute('SELECT COUNT(*) FROM vulnerabilities')
            summary['total_vulnerabilities'] = self.db.cursor.fetchone()[0]

            # Conteggio per severità
            self.db.cursor.execute('''
                SELECT severity, COUNT(*) 
                FROM vulnerabilities 
                GROUP BY severity 
                ORDER BY 
                    CASE severity 
                        WHEN 'CRITICAL' THEN 1 
                        WHEN 'HIGH' THEN 2 
                        WHEN 'MEDIUM' THEN 3 
                        WHEN 'LOW' THEN 4 
                        ELSE 5 
                    END
            ''')
            summary['by_severity'] = dict(self.db.cursor.fetchall())

            # Conteggio per tipo
            self.db.cursor.execute('''
                SELECT vuln_type, COUNT(*) 
                FROM vulnerabilities 
                GROUP BY vuln_type 
                ORDER BY COUNT(*) DESC
            ''')
            summary['by_type'] = dict(self.db.cursor.fetchall())

            # Host più vulnerabili
            self.db.cursor.execute('''
                SELECT ip_address, COUNT(*) as vuln_count
                FROM vulnerabilities 
                GROUP BY ip_address 
                ORDER BY vuln_count DESC 
                LIMIT 10
            ''')
            summary['most_vulnerable_hosts'] = self.db.cursor.fetchall()

            # CVE più comuni
            self.db.cursor.execute('''
                SELECT cve_id, COUNT(*) as count
                FROM vulnerabilities 
                WHERE cve_id IS NOT NULL 
                GROUP BY cve_id 
                ORDER BY count DESC 
                LIMIT 10
            ''')
            summary['common_cves'] = self.db.cursor.fetchall()

            return summary

        except Exception as e:
            logger.error(f"Errore generazione summary vulnerabilità: {e}")
            return {}

    def export_vulnerabilities_report(self, output_file: str = "../reports/vulnerabilities_report.txt"):
        """Esporta un report dettagliato delle vulnerabilità"""
        try:
            import os
            os.makedirs("../reports", exist_ok=True)

            with open(output_file, 'w', encoding='utf-8') as f:
                f.write("REPORT VULNERABILITÀ NETWORK SCAN\n")
                f.write("=" * 50 + "\n\n")

                # Summary
                summary = self.get_vulnerability_summary()
                f.write(f"Vulnerabilità totali trovate: {summary.get('total_vulnerabilities', 0)}\n\n")

                if summary.get('by_severity'):
                    f.write("Distribuzione per severità:\n")
                    for severity, count in summary['by_severity'].items():
                        f.write(f"  {severity}: {count}\n")
                    f.write("\n")

                # Dettaglio vulnerabilità critiche e high
                self.db.cursor.execute('''
                    SELECT ip_address, port_number, protocol, severity, title, cve_id, description
                    FROM vulnerabilities 
                    WHERE severity IN ('CRITICAL', 'HIGH')
                    ORDER BY 
                        CASE severity WHEN 'CRITICAL' THEN 1 ELSE 2 END,
                        ip_address
                ''')

                critical_high_vulns = self.db.cursor.fetchall()

                if critical_high_vulns:
                    f.write("VULNERABILITÀ CRITICHE E HIGH:\n")
                    f.write("-" * 40 + "\n")

                    for vuln in critical_high_vulns:
                        ip, port, proto, sev, title, cve, desc = vuln
                        f.write(f"\nHost: {ip}")
                        if port:
                            f.write(f" - Porta: {port}/{proto}")
                        f.write(f"\nSeverità: {sev}")
                        f.write(f"\nTitolo: {title}")
                        if cve:
                            f.write(f"\nCVE: {cve}")
                        f.write(f"\nDescrizione: {desc}")
                        f.write(f"\n{'-' * 30}\n")

                f.write("\nReport generato automaticamente dal parser Nmap XML\n")

            logger.info(f"Report vulnerabilità esportato in: {output_file}")

        except Exception as e:
            logger.error(f"Errore esportazione report vulnerabilità: {e}")